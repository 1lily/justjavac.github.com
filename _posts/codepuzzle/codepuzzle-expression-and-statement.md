2012-10-28 语句与表达式

## 语句与表达式

虽然文章标题是『语句与表达式』，在这篇文章中，我将陈述一个观点 **每个表达式都有一个值**。
在此之外，也会继续表述这个『代码之谜』系列的主题——数学与计算机之间被经常忽略的矛盾。

简单的讲

* "表达式"（expression）是一个单纯的运算过程，总是有返回值；
* "语句"（statement）是执行某种操作，没有返回值。

使用表达式也是函数式编程语言所提倡的，而传统命令式编程语言都是语句的堆砌。

表达式和语句如何区分呢？
最简单最直观的鉴别方法就是，**后面有分号的是语句**，这是一个充分条件而不是必要条件。
有分号，就是语句；没有分号，就不一定了，也可能是语句，也可能是表达式。

在动态语言——比如javascript——中是通过上下文来区分这两者的。

假如 function foo(){} 是一个赋值表达式的一部分，则认为它是一个表达式。
**表达式的一部分，也是表达式**。
而如果 function foo(){} 被包含在一个函数体内，或者位于程序中，则将它作为一个语句。

	function foo(){}; // 声明，因为它是程序的一部分
	var bar = function foo(){}; // 表达式，因为它是赋值表达式的一部分

	new function bar(){}; // 表达式，因为它是New表达式的一部分

	(function(){
		function bar(){}; // 声明，因为它是函数体的一部分
	})();

还有一种不那么显而易见的表达式，就是被包含在一对圆括号中—— (function foo(){})。
将这种形式看成表达式同样是因为上下文的关系：
(和)构成一个分组操作符，而 **分组操作符只能包含表达式**：

	(function foo(){}); // 函数表达式：注意它被包含在分组操作符中
	(var x = 5);  // error! 分组操作符只能包含表达式，不能包含语句（这里的var就是语句）
	
今天突然有人问我： 
	
	alert(eval(data));

为什么会报错呢？data 是一个对象，按理说应该会弹出 Object[Object] 啊。
这是因为，当我们写 

	{"username" : "justjavac"} 
	
时，它并不是一个对象。
因为我们知道有一种表示数据的方法叫做 json（javascript对象表示法），
所以想当然的认为这应该是一个对象。
其实，在大部分编程语言中，大括号（{}）表示的不是对象，而是代码块，这段代码其实等价于

	{
		"username" : "justjavac"
	}

很显然，`"username" : "justjavac"` 并不是合法的语句。
然而解决方法也很简单，就是添加括号——分组操作符

	({"username" : "justjavac"})

这样就构成了一个合法的表达式，当我们进行 json 对象解析的时候可以写如下代码：

	eval('(' + json + ')')

**在表达式中，只能存在表达式，不能存在语句。**

例如表达式

	(var a = 4) + 4;

这段代码将产生一个错误，因为 `var a = 4` 是一个语句，
而不是表达式—— **对表达式求值必须返回值，但对语句求值则未必有返回值**。

类似的

	if (var a = 0) {}
	
也产生错误。

## 运算符

从最简单的运算符加号(+)说起，加号(+)是个二元运算符——也就是说，**加号只把两个数联接起来，从来不把第三个或者更多的联接起来**。

因此，“1加2加3” 在计算机中被表述为：

	(1 + 2) + 3      // a

或者

	1 + (2 + 3)      // b

虽然我们通常写做 `1 + 2 + 3`，但是并不意味这它和我们数学中的 1+2+3 是等价的。

那么数学中的 1+2+3 到底表示的是 a 呢，还是 b 呢？

如果计算机的求值是左结合的，那么此表达式等价于第一种a；
如果是右结合的，那么此表达式等价于第二种b。

`1 + 2 + 3` 简单的理解就是 “把1、2、3加在一起”，
确实，在我们接触到的数学里面，就是把三个数加起来。
但是在编程语言中，却不仅仅这样。

就像前面说的那样，+号无法操作三个或者更多的数，参与加法运算的只能是两个数。

顺便说一句，正号、负号是一元运算符，虽然它们和二元运算符加、减用相同的符号，
但是他们却是不同的，所以不要想当然的认为 +4 就等等价于 0+4。

在 java 中，我们可以写 `short a = -4`，但是当我们写 `short a = 0 - 4` 时则产生一个警告。

还有一个其它例子，同样是关于 short 的，

	short b = 1;
	short b = b + 4;   // 警告
	short b += 4;      // 无警告

那么 `1 + 2 + 3` 是如何运算的呢？
在冯诺依曼体系架构的编程语言中，
这里有一个副作用——我习惯称那些“计算机的运算过程 和 程序员的大脑思考过程不一样时，则称为副作用”（虽然书本没有这么写过，但我一向这么认为），本来你以为会是这样，
结果计算机偏偏就不是这样做的，我称他为副作用。

如果看过前面的『语句与表达式』，这可以这么理解：

1 + 2 是一个表达式，它的返回值是 3。
这个表达式的返回值再参加到另一个表达式中 3 + 3，最后得出结果6。

我们用语句（Statement）来改写这段代码：

	// 计算 1 + 2 + 3
	var a = 1 + 2;
	var b = b + 3;

如果我们用 lisp 语言对这个表达式求值，则没有副作用。

	(+ (+ 1 2) 3)

如果你还没有懂，或者这个例子太有特殊性，那么我们换一个

	5 > 4 > 3

在数学中，这个算式的值为 true。当我们用C语言来写这段代码，它返回的确实 false。

原因和上面的一样，大于号(>)是二元运算，它无法直接比较三个数，5 > 4 返回的结果是 true，
当用 true 和 3 比较时，true 被转换称 1，也就是 `1 > 3`，最终的结果自然就是 false 了。

总之，回归到了『语句与表达式』篇的那个观点：在编程语言中 **每个表达式都有一个值**。



